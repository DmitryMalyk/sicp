Лиза П. Хакер не понимает, почему if должна быть особой формой. 
«Почему нельзя просто определить ее как обычную процедуру с помощью cond?» 
— спрашивает она. 
Лизина подруга Ева Лу Атор определяет новую версию if:

(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
		
(new-if (= 2 3) 0 5)
5
(new-if (= 1 1) 0 5)
0

Обрадованная Лиза переписывает через new-if программу вычисления квадратного корня:
(define (sqrt-iter guess x)
	(new-if (good-enough? guess x)
		guess
			(sqrt-iter (improve guess x)
						  x)))

Что получится, когда Лиза попытается использовать эту процедуру для вычисления квадратных
корней? Объясните.

(define (sqrt x)
  (sqrt-iter 1.0 x))
  
Ответ: 

Данное задание перекликается с заданием 1.5 и 
так же связано с порядком вычисления и особой формой if.

Обычная процедура new-if будет вычисляться в аппликативном порядке.
Таким образом, не смотря на итог вычисления предиката в new-if, 
альтернатива, содержащая рекурсивное вычисление процедуры sqrt-iter, 
будет в любом случае вычислена.  

Тот факт, что после вычисления предиката в особой форме if выбирается 
лишь одно из двух значений (следствие или альтернатива), 
позволяет по достижении положительного результата 
проверки good-enough? в (if (good-enough? guess x) перейти к вычислению следствия, 
не вычисляя альтернативу. 

Т.е. в отличие от процедуры new-if, в особой форме if 
есть возможожность остановки рекурсивных вычислений заложенных в альтернативе. 
Процедура new-if же погрязнет в бесконечной рекурсии. 

